#version 430 core

layout (location = 0) in vec2 position;
out vec2 texCoordOut;
out vec2 levelPositionOut;
out vec2 levelPositionFnrOut;

uniform sampler2D tex_heightmap; 
uniform sampler2D tex_pixelmap; 

uniform int levelIndex;
uniform sampler2D tex_heightmap0;
uniform sampler2D tex_heightmap1;
uniform sampler2D tex_heightmap2;
uniform sampler2D tex_heightmap3;
uniform sampler2D tex_heightmap4;
uniform sampler2D tex_heightmap5;
uniform sampler2D tex_heightmap6;
uniform sampler2D tex_heightmap7;
uniform sampler2D tex_heightmap8;
uniform sampler2D tex_heightmap9;
uniform sampler2D tex_heightmap10;
uniform sampler2D tex_heightmap11;
uniform sampler2D tex_heightmap12;

uniform vec2 patchOrigin;
uniform vec2 levelScaleFactor;
uniform vec2 worldScaleFactor;
uniform vec2 worldOffset;
uniform mat4 modelView;
uniform int n;

uniform vec2 hgtTexOffset;
uniform vec2 hgtTexOffsetFnr;

//uniforms for blending
uniform vec2 coarserInFinerOffset;
uniform float w;
uniform float distanceToBlendingArea;
uniform vec2 cameraPosition;
uniform int highestLvlOfDetail;

float CONST_PIDIV180 = 0.01745329251;
int earthRadius = 6378100;

vec2 getTexelValue(int index, vec2 position) {
	
	vec2 texelValue;

	switch (index) {
	case 0:
		texelValue = texture(tex_heightmap0, vec2(position.x/n, position.y/n), 0).xy;
		break;
	case 1:
		texelValue = texture(tex_heightmap1, vec2(position.x/n, position.y/n), 0).xy;
		break;
	case 2:
		texelValue = texture(tex_heightmap2, vec2(position.x/n, position.y/n), 0).xy;
		break;
	case 3:
		texelValue = texture(tex_heightmap3, vec2(position.x/n, position.y/n), 0).xy;
		break;
	case 4:
		texelValue = texture(tex_heightmap4, vec2(position.x/n, position.y/n), 0).xy;
		break;									 
	case 5:										 
		texelValue = texture(tex_heightmap5, vec2(position.x/n, position.y/n),  0).xy;
		break;									 
	case 6:										 
		texelValue = texture(tex_heightmap6, vec2(position.x/n, position.y/n),  0).xy;
		break;									 
	case 7:										 
		texelValue = texture(tex_heightmap7, vec2(position.x/n, position.y/n),  0).xy;
		break;									 
	case 8:										 
		texelValue = texture(tex_heightmap8, vec2(position.x/n, position.y/n),  0).xy;
		break;									 
	case 9:										 
		texelValue = texture(tex_heightmap9, vec2(position.x/n, position.y/n),  0).xy;
		break;									 
	case 10:									 
		texelValue = texture(tex_heightmap10, vec2(position.x/n, position.y/n), 0).xy;
		break;									 
	case 11:									 
		texelValue = texture(tex_heightmap11, vec2(position.x/n, position.y/n), 0).xy;
		break;									 
	case 12:									 
		texelValue = texture(tex_heightmap12, vec2(position.x/n, position.y/n), 0).xy;
		break;
	}

	return texelValue;
}

void main()
{
	vec2 levelPosition, levelPositionFnr, texPosition, worldPosition;
	vec2 texelValue, texelValueFnr;
    
	float terrainHeight;
	float x, y, z;

	float blendingParam, blendingParamX, blendingParamY;
	
	
	//checking level position of coarser level
    levelPosition = position + patchOrigin;


	texPosition.x = mod(levelPosition.x  + 0.5 + hgtTexOffset.x, n);
	texPosition.y = mod(levelPosition.y  + 0.5 + hgtTexOffset.y, n);

	texelValue = getTexelValue(levelIndex, texPosition);


	if(highestLvlOfDetail > levelIndex){
		
		//checking level position of finer level
		levelPositionFnr = 0.5 * (position + patchOrigin) + coarserInFinerOffset;
	
		texPosition.x = mod(levelPositionFnr.x + 0.5 + hgtTexOffsetFnr.x, n);
		texPosition.y = mod(levelPositionFnr.y + 0.5 + hgtTexOffsetFnr.y, n);
		
		texelValueFnr = getTexelValue(levelIndex + 1, texPosition);


		//calculating blending parameter
		blendingParamX = clamp( ( abs(levelPosition.x-cameraPosition.x) - distanceToBlendingArea )/w ,0,1);
		blendingParamY = clamp( ( abs(levelPosition.y-cameraPosition.y) - distanceToBlendingArea )/w ,0,1);
		blendingParam = max( blendingParamX, blendingParamY);

		
		terrainHeight = mix( (texelValue.x*256+texelValue.y*65280), (texelValueFnr.x*256+texelValueFnr.y*65280), blendingParam);
	}
	else {
		terrainHeight = (texelValue.x*256+texelValue.y*65280);
	}

	//calculating level position in cartesian coordinates
    worldPosition = (levelPosition * levelScaleFactor * worldScaleFactor) + worldOffset;


    x = (earthRadius + terrainHeight) * sin(worldPosition.x * CONST_PIDIV180) * cos(worldPosition.y * CONST_PIDIV180);
    y = (earthRadius + terrainHeight) * sin(worldPosition.y * CONST_PIDIV180);
    z = (earthRadius + terrainHeight) * cos(worldPosition.x * CONST_PIDIV180) * cos(worldPosition.y * CONST_PIDIV180);

	levelPositionFnrOut = levelPositionFnr;
    levelPositionOut = levelPosition;
    gl_Position = modelView*vec4(x, y, z, 1.0);    
}